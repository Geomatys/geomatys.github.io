<!DOCTYPE html>
<html>
  <head>
    <title>Multiple Java modules in a single Gradle sub-project</title>
    <meta charset="UTF-8">
    <style>
      h2 {
        border-top: solid;
        border-width: 6px;
        border-color: DarkTurquoise;
        margin-top:  80px;
        padding-top: 80px;
      }
      h3 {
        margin-top:   48px;
        margin-bottom: 9px;
      }
      h4 {
        margin-top:   32px;
        margin-bottom: 9px;
      }
      p {
        text-align: justify;
        font-size:  16px;
      }
      blockquote, li {
        font-size: 16px;
      }
      pre {
        font-size: 14px;
      }
      pre.snippet {
        padding:      20px;
        margin-left:  80px;
        margin-right: 80px;
        border-style: solid;
        border-width: 1px;
        border-color: gray;
        background:   #F8F8F8;
      }
      pre.tree {
        font-size:   18px;
        line-height: 100%;
        color: gray;
      }
      pre.tree span.plain, pre.tree span.del, pre.tree span.new, pre.tree span.use, pre.tree span.note {
        font-size: 14px;
      }
      pre.tree span.del, pre.tree span.new, pre.tree span.use  {
        font-weight: bold
      }
      span.plain {color: black}
      span.new   {color: SteelBlue}
      span.del   {color: red}
      span.use   {color: green}
      span.note  {font-family: serif; font-style: italic}
      span.string {color: DarkGoldenRod}

      table.two-columns {
        margin-left:  auto;
        margin-right: auto;
        border-style: solid;
        border-width: 3px;
        background: #F8F8F8;
      }
      table.two-columns tr {
        vertical-align: top;
      }
      table.two-columns td {
        padding-left:   20px;
        padding-right: 130px;
      }
      table.two-columns th.next, table.two-columns td.next {
        border-left: 3px solid;
      }
    </style>
  </head>
  <body>
    <h1>Multiple Java modules in a single Gradle sub-project</h1>
    <p>
      Since the release of Java 9 and the Java Platform Module System (<abbr>JPMS</abbr>, code-named "Jigsaw"),
      the tendency in Maven or Gradle projects is to either ignore JPMS,
      or to consider Java modules as equivalent to Maven modules or Gradle sub-projects:
      each Maven module contains exactly one Java module,
      and the same convention is applied to Gradle sub-projects.
      However this restriction is technically not necessary.
      We could use a slightly more neutral interpretation of Maven module
      by saying that each Maven module contains exactly one Java compilation task,
      i.e. one call to <code>javac</code> or <code>javadoc</code>,
      and leave out all <abbr title="Java Platform Module System">JPMS</abbr> considerations
      (except during <abbr title="Java Archive File">JAR</abbr> packaging)
      as Java tools internal business.
    </p><p>
      Since Java 9, the <code>javac</code> and <code>javadoc</code> tools can process many Java modules together.
      Allowing that multiplicity in developer's project has some advantages described in this page.
      To summarize, it gives to developers an extra level of flexibility for organizing their modules,
      enables more compile-time checks of cross-module documentation,
      facilitates aggregated javadoc and aggregated annotation processing,
      facilitates the reuse of test fixtures between modules, and more.
      However taking full advantage of <abbr title="Java Platform Module System">JPMS</abbr>
      requires changes in the directory layout compared to Maven and Gradle conventions.
      As of June 2023, both Maven and Gradle support only a directory layout known as <i>Package Hierarchy</i>.
      However since Java 9, <code>javac</code> supports another layout known as <i>Module Source Hierarchy</i>
      (source: <code>javac</code> <a href="https://docs.oracle.com/en/java/javase/20/docs/specs/man/javac.html#directory-hierarchies">Directory Hierarchies</a>).
      This page describes how the Module Source Hierarchy can be applied to the <a href="https://sis.apache.org/">Apache SIS</a> project.
      The layout described below is currently very difficult to apply with Maven,
      so this page will provide code snippets for Gradle only.
    </p>

    <h2>1) Overview of directory layout change</h2>
    <p>
      Multiple Java modules in a single Gradle sub-project does not mean that Gradle sub-projects should be abandoned.
      Instead, Java modules introduces one new level of sub-division between Gradle sub-projects and Java packages,
      illustrated by the blue line below. Developers should be free to use it or not,
      and to choose what to group as a Gradle sub-project and what to group as a Java module.
    </p>
    <ol>
      <li>A Gradle project can be (if desired) a tree of Gradle sub-projects.</li>
      <li><span class="new">Each Gradle leaf sub-project can contain many Java modules.</span></li>
      <li>Each Java module can contain many Java packages.</li>
    </ol>
    <p>
      Java provides some flexibility about the directory layout in a Module Source Hierarchy.
      In this section, we assume that the developer wants to stay close to Maven conventions.
      The <span class="use">names in green</span> are directories taken unchanged from Maven conventions
      and <span class="new">names in blue</span> are new directories added for Module Source Hierarchy support.
      The <span class="del">names in red</span> are directories from Maven conventions that we propose to drop,
      but this is an arbitrary proposal for Apache <abbr title="Spatial Information System">SIS</abbr> restructuring
      that does not need to be adopted (the <code>java</code> directory relevance is a separated debate).
      In the figure below, the paths on the left side can become the paths on the right side,
      where <span class="new"><var>&lt;module&gt;</var></span> shall be replaced by a
      <abbr title="Java Platform Module System">JPMS</abbr> module name
      such as <span class="new"><code>org.apache.sis.storage</code></span>.
    </p>
    <table class="two-columns">
      <tr>
        <th>Current Maven layout</th>
        <th class="next">Module Source Hierarchy</th>
      </tr>
      <tr>
        <td>
          <ul>
            <li><var>&lt;Gradle project or sub-project&gt;</var>
              <ul>
                <li><var>&lt;Gradle sub-project&gt;</var>
                  <ul>
                    <li><span class="use">src</span>/<span class="use">main</span>/<span class="del">java</span></li>
                    <li><span class="use">src</span>/<span class="use">test</span>/<span class="del">java</span></li>
                  </ul>
                <li>Repeat for other Gradle sub-projects</li>
              </ul>
            </li>
          </ul>
        </td><td class="next">
          <ul>
            <li><var>&lt;Gradle project or sub-project&gt;</var>
              <ul>
                <li><span class="use">src</span>/<span class="new"><var>&lt;module&gt;</var></span>/<span class="use">main</span>/<span class="del">java</span></li>
                <li><span class="use">src</span>/<span class="new"><var>&lt;module&gt;</var></span>/<span class="use">test</span>/<span class="del">java</span></li>
                <li>Repeat for other <abbr title="Java Platform Module System">JPMS</abbr> modules</li>
              </ul>
            </li>
            <li>Separated Gradle sub-projects are still possible if desired</li>
          </ul>
        </td>
      </tr>
    </table>
    <p>
      When compiling with <code>javac</code>, the root source directory shall be the <span class="use">src</span> directory containing all
      modules rather than the <span class="del">java</span> directory containing the <code>org/apache/sis/…</code> hierarchy of packages.
      The <span class="new"><var>&lt;module&gt;</var></span> directory names shall be identical to the module names declared in <code>module-info.java</code>.
      An arbitrary amount of custom directories can be inserted between the <span class="new"><var>&lt;module&gt;</var></span> directory
      and the start of the package directories (e.g. <code>org/apache/sis/…</code>).
      This insertion of custom directories is the difference between <i>Module Hierarchy</i>
      and <i>Module <u>Source</u> Hierarchy</i> in <code>javac</code> documentation.
      The custom directories shall be declared with the <code>--module-source-path</code> option like below,
      where the <code>*</code> character will be automatically replaced by
      <span class="new"><var>&lt;module&gt;</var></span> by the <code>javac</code> compiler:
    </p>
    <blockquote><code>
      javac <b>--module-source-path</b>=<var>/path/to/subproject</var>/<span class="use">src</span>/*/<span class="use">main</span>/<span class="del">java</span>
    </code></blockquote>
    <p>
      The options for compiling the tests are similar with <span class="use">main</span> replaced by <span class="use">test</span>
      (or anything else at user's choice) like below:
    </p>
    <blockquote><code>
      javac <b>--module-source-path</b>=<var>/path/to/subproject</var>/<span class="use">src</span>/*/<span class="use">test</span>/<span class="del">java</span>
    </code></blockquote>
    <p>
      Users are free to add other sub-directories, for example <span class="use"><code>resources</code></span>,
      under the <span class="new"><var>&lt;module&gt;</var></span> directory.
      Everything that do not match the pattern given to the <code>--module-source-path</code> option will be ignored.
      So the main sources, the tests and the resources can be all located under the same module directory,
      in a way close to Maven convention if desired.
      How to apply those options in a Gradle project will be discussed <a href="#gradle-config">later on this page</a>.
    </p>




    <h2>2) Apache SIS restructuring</h2>
    <p>
      This section discusses a proposed restructuring of the <a href="https://sis.apache.org/">Apache SIS</a> project
      following the Module Source Hierarchy. It can been seen as an example of one possible approach for distributing
      modules between <abbr title="Java Platform Module System">JPMS</abbr> modules and Gradle sub-projects.
      For more generic discussion about Gradle configuration, jump to the <a href="#gradle-config">next section</a>.
    </p><p>

      The tree on the left side shows the current directory layout as of May 2023, which follows Maven conventions.
      The tree on the right side shows a new directory layout proposal.
      The <span class="new">names in blue</span> are new directory levels.
      The <span class="del">names in red</span> are removed directory levels.
      The <span class="use">names in green</span> are directory levels kept unchanged.
      The <span class="use">src</span>, <span class="use">main</span>,
      <span class="use">test</span> and <span class="del">java</span>
      directories are from Maven conventions.
      The other changes shown below are a proposed restructuring of the
      Apache <abbr title="Spatial Information System">SIS</abbr> project.
      Resources are omitted in this discussion for simplicity.
    </p>

    <table class="two-columns">
      <tr>
        <th>Current Maven layout</th>
        <th class="next">Module Source Hierarchy</th>
      </tr>
      <tr>
        <td>
          <pre class="tree"><span class="note">Apache SIS project root</span>
├── <span class="plain">pom.xml</span>
├── <span class="del">core</span>
│   ├── <span class="plain">pom.xml</span>
│   ├── <span class="del">sis-util</span>
│   │   ├── <span class="plain">pom.xml</span>
│   │   └── <span class="use">src</span>
│   │       ├── <span class="use">main</span>
│   │       │   └── <span class="del">java</span>
│   │       │       └── <span class="plain">org/apache/sis/…</span>
│   │       └── <span class="use">test</span>
│   │           └── <span class="del">java</span>
│   │               └── <span class="plain">org/apache/sis/…</span>
│   ├── <span class="del">sis-metadata</span>
│   │   └── <span class="note">Same structure, omitted for brevity.</span>
│   ├── <span class="del">sis-referencing</span>
│   ├── <span class="del">sis-referencing-by-identifiers</span>
│   ├── <span class="del">sis-feature</span>
│   ├── <span class="del">sis-cql</span>
│   └── <span class="del">sis-portrayal</span>
├── <span class="del">storage</span>
│   ├── <span class="plain">pom.xml</span>
│   ├── <span class="del">sis-storage</span>
│   │   ├── <span class="plain">pom.xml</span>
│   │   └── <span class="use">src</span>
│   │       ├── <span class="use">main</span>
│   │       │   └── <span class="del">java</span>
│   │       │       └── <span class="plain">org/apache/sis/…</span>
│   │       └── <span class="use">test</span>
│   │           └── <span class="del">java</span>
│   │               └── <span class="plain">org/apache/sis/…</span>
│   ├── <span class="del">sis-shapefile</span>
│   │   └── <span class="note">Same structure, omitted for brevity.</span>
│   ├── <span class="del">sis-xmlstore</span>
│   ├── <span class="del">sis-sqlstore</span>
│   ├── <span class="del">sis-netcdf</span>
│   ├── <span class="del">sis-geotiff</span>
│   └── <span class="del">sis-earth-observation</span>
├── <span class="del">cloud</span>
│   ├── <span class="plain">pom.xml</span>
│   └── <span class="del">sis-cloud-aws</span>
├── <span class="del">profiles</span>
│   ├── <span class="plain">pom.xml</span>
│   ├── <span class="del">sis-france-profile</span>
│   └── <span class="del">sis-japan-profile</span>
└── <span class="del">application</span>
    ├── <span class="plain">pom.xml</span>
    ├── <span class="del">sis-console</span>
    ├── <span class="del">sis-webapp</span>
    ├── <span class="del">sis-openoffice</span>
    └── <span class="del">sis-javafx</span></pre></td>


        <td class="next">
          <pre class="tree"><span class="note">Apache SIS project root</span>
├── <span class="plain">settings.gradle.kts</span>
├── <span class="new">endorsed</span>
│   ├── <span class="plain">build.gradle.kts</span>
│   └── <span class="use">src</span>
│       ├── <span class="new">org.apache.sis.util</span>
│       │   ├── <span class="use">main</span>
│       │   │   ├── <span class="plain">module-info.java</span>
│       │   │   └── <span class="plain">org/apache/sis/…</span>
│       │   └── <span class="use">test</span>
│       │       └── <span class="plain">org/apache/sis/…</span>
│       ├── <span class="new">org.apache.sis.metadata</span>
│       │   └── <span class="note">Same structure, omitted for brevity.</span>
│       ├── <span class="new">org.apache.sis.referencing</span>
│       ├── <span class="new">org.apache.sis.referencing.gazetteer</span>
│       ├── <span class="new">org.apache.sis.feature</span>
│       ├── <span class="new">org.apache.sis.storage</span>
│       ├── <span class="new">org.apache.sis.storage.xml</span>
│       ├── <span class="new">org.apache.sis.storage.sql</span>
│       ├── <span class="new">org.apache.sis.storage.netcdf</span>
│       ├── <span class="new">org.apache.sis.storage.geotiff</span>
│       ├── <span class="new">org.apache.sis.storage.earthobservation</span>
│       ├── <span class="new">org.apache.sis.cloud.aws</span>
│       ├── <span class="new">org.apache.sis.portrayal</span>
│       ├── <span class="new">org.apache.sis.profile.france</span>
│       ├── <span class="new">org.apache.sis.profile.japan</span>
│       ├── <span class="new">org.apache.sis.console</span>
│       ├── <span class="new">org.apache.sis.openoffice</span>
│       └── <span class="new">org.apache.sis.test</span> <span class="note">(new module, see below)</span>
│           └── <span class="use">test</span>
│               └── <span class="plain">module-info.java</span>
├── <span class="new">incubator</span>
│   ├── <span class="plain">build.gradle.kts</span>
│   └── <span class="use">src</span>
│       ├── <span class="new">org.apache.sis.cql</span>
│       │   ├── <span class="use">main</span>
│       │   │   ├── <span class="plain">module-info.java</span>
│       │   │   └── <span class="plain">org/apache/sis/…</span>
│       │   └── <span class="use">test</span>
│       │       └── <span class="plain">org/apache/sis/…</span>
│       ├── <span class="new">org.apache.sis.storage.shapefile</span>
│       │   └── <span class="note">Same structure, omitted for brevity.</span>
│       └── <span class="new">org.apache.sis.webapp</span>
└── <span class="new">optional</span>
    ├── <span class="plain">build.gradle.kts</span>
    └── <span class="use">src</span>
        └── <span class="new">org.apache.sis.gui</span>
            └── <span class="note">Same structure, omitted for brevity.</span></pre>
        </td>
      </tr>
    </table>
    <p>
      In the old layout (left side),
      the Apache <abbr title="Spatial Information System">SIS</abbr> project organized modules in some groups:
      <i>core</i>, <i>storage</i>, <i>cloud</i>, <i>profiles</i> and <i>application</i>.
      While this grouping can be useful for understanding the content
      of the Apache <abbr title="Spatial Information System">SIS</abbr> project,
      it serves no purpose from the point of view of build management.
      In the new layout (right side), that grouping is removed from the directory tree.
      Such logical grouping can appear in <abbr title="Java Platform Module System">JPMS</abbr>
      module names if desired, for example <code>org.apache.sis.<b>storage</b>.*</code>,
       <code>org.apache.sis.<b>cloud</b>.*</code> and <code>org.apache.sis.<b>profile</b>.*</code>.
      The old "build-irrelevant" grouping is replaced by a new grouping which is relevant to the build:
    </p>
    <ul>
      <li>The <b>endorsed</b> sub-project contains all modules that are included in
          official Apache <abbr title="Spatial Information System">SIS</abbr> releases.</li>
      <li>The <b>incubator</b> sub-project contains modules that are not yet ready for release.</li>
      <li>The <b>optional</b> sub-project contains modules requiring agreement with license terms
          more restrictive than Apache 2.</li>
    </ul>
    <p>
      With the new layout, modules that are not ready for release can be easily excluded all together.
      By comparison, with the old layout the release manager had to manually exclude various modules
      scattered in the tree.
      Likewise, the optional modules can be included or excluded all together depending on license agreement.
      For example the <abbr title="Graphical User Interface">GUI</abbr> depends on JavaFX and can be included
      in the build only on acceptance of <abbr title="GNU General Public License">GPL</abbr> terms.
      This new way of grouping modules will hopefully simplify
      Apache <abbr title="Spatial Information System">SIS</abbr> releases.
    </p>
    <h3>2.1) Consequence on cross-module dependencies</h3>
    <p>
      In the new layout, the replacement of Maven modules by <abbr title="Java Platform Module System">JPMS</abbr>
      modules has a desirable side-effect.
      In the old layout, any Maven module could depend on any other Maven module as long as there is no cycle.
      Maven determines the modules build order regardless if modules belong to the same groups or not.
      So nothing (except cycles) prevented a module in the <span class="del">core</span> group to depend
      on a module in incubation or subject to restrictive license terms.
      With the new layout, the <span class="new">endorsed</span>, <span class="new">incubator</span> and
      <span class="new">optional</span> sub-projects are the finest level of grouping managed by the build system.
      The <abbr title="Java Platform Module System">JPMS</abbr> modules inside those sub-projects cannot be managed
      independently by the build system, which has advantages and inconvenient.
      An advantage for Apache <abbr title="Spatial Information System">SIS</abbr> is that compile-time dependency of
      <span class="new">endorsed</span> modules toward any <span class="new">incubator</span> or
      <span class="new">optional</span> modules become impossible
      (however, runtime dependency through Service Provider Interfaces is still possible).
    </p>
    <h3>2.2) Dropping the separation between source and resources</h3>
    <p>
      For the Apache <abbr title="Spatial Information System">SIS</abbr> restructuring,
      we propose to drop the <span class="del">java</span> directory.
      The consequence would be that resources are no longer separated from Java source code.
      The Maven's convention putting resources in a separated directory hierarchy
      is considered a good practice by some, but this is not an universal opinion.
      NetBeans Ant projects and OpenJDK for example don't do that.
      The argument is similar to documentation, which was traditionally separated from the code in previous programming languages.
      The Java designers decided that the best place to put documentation (javadoc) was close to the code.
      Having resources close to the code has similar advantages.
      It makes more likely that the developer sees when a change in a class may require a change in a resource,
      and less tedious to open that file (no need to navigate through the exact same path in a separated directory hierarchy).
      Furthermore, the Maven's convention separating <span class="del">java</span> and <span class="del">resources</span>
      does not work well in a multi-languages project anyway, because it does not distinguish
      the Java resources to copy in a <abbr title="Java Archive File">JAR</abbr> file
      from the C/C++ or Python resources (for example).
      Mixing two languages in the same module happens when the module is a bridge between those two languages,
      such as <a href="https://github.com/OSGeo/PROJ-JNI">PROJ-JNI</a> (between Java and C/C++)
      and <a href="http://www.geoapi.org/java-python/index.html">GeoAPI bridge</a> (between Java and Python).
    </p>
    <h3>2.3) Test module</h3>
    <p>
      The new layout contains a module, named <span class="new"><code>org.apache.sis.test</code></span>,
      that did not existed in the old layout. This module is local to the build and never deployed.
      It has no <code><span class="use">main</span></code> sub-directory,
      only a <code><span class="use">test</span>/module-info.java</code> file.
      This is a convenient way to declare dependencies that are needed by the tests
      but not declared in any <code><span class="use">main</span>/module-info.java</code> file being compiled.
      Actually our experiments suggest that the <code>--add-reads</code> option does not work well if the added
      module does not appear in a <code>requires</code> clause of at least one <code>module-info.java</code> file.
      The <span class="new"><code>org.apache.sis.test</code></span> module resolves that problem.
    </p><p>
      Maven has a different approach which allows the tests to overwrite the main <code>module-info</code> files.
      We don't do that because those files are sometime a bit large,
      and we want to avoid the risk of overwriting them with
      <code><span class="use">test</span>/module-info.java</code> files that differ in unintended ways.
      In our proposed approach, the <span class="new"><code>org.apache.sis.test</code></span> module information
      is added to the <code>module-info</code> files of all modules to test instead of overwriting them.
    </p>




    <h2 id="gradle-config">3) Gradle configuration for Module Source Hierarchy</h2>
    <p>
      It is possible to get Gradle to work to some extent without writing a custom plugin.
      The hacks are not very clean, but could be much better with a little bit of improvement from Gradle.
      The "<a href="#gradle-proposals">Ideas for Gradle evolution</a>" section provides some proposals.
      The key information that needs to be supplied are:
    </p>
    <ul>
      <li>For compiling the main code:
        <ul>
          <li><code><b>--module-path</b></code> <var>&lt;paths to all dependencies&gt;</var></li>
          <li><code><b>--module-source-path</b> /<var>path_to_sub_project</var>/<span class="use">src</span>/*/<span class="use">main</span>/<span class="del">java</span></code></li>
          <li><code><b>--add-modules</b> <var>module_1</var>,<var>module_2</var>,<var>module_3</var>,</code>…
              (list all modules of the project, not dependencies)</li>
        </ul>
      </li>
      <li>For compiling the test code:
        <ul>
          <li><code><b>--module-path</b></code> <var>&lt;paths to dependencies including the directory containing the output of above compilation of main modules&gt;</var></li>
          <li><code><b>--module-source-path</b> /<var>path_to_sub_project</var>/<span class="use">src</span>/*/<span class="use">test</span>/<span class="del">java</span></code></li>
          <li><code><b>--patch-module</b> <var>module_1</var>=<var>/path_to_sub_project</var>/<span class="use">src</span>/<var>module_1</var>/<span class="use">test</span>/<span class="del">java</span></code>
              (repeat for each module)</li>
          <li><code><b>--add-modules</b></code> <var>&lt;same as for compilation of main code&gt;</var></li>
          <li><code><b>--add-reads</b> <var>module_1</var>=<var>dependency_A</var>,<var>dependency_B</var>,</code>… for all test-only dependencies such as JUnit
              (repeat for each module)</li>
        </ul>
      </li>
      <li>For executing the test code:
        <ul>
          <li><code><b>--module-path</b></code> <var>&lt;paths to dependencies and compilation result of main modules, but <strong>excluding compilation result of test classes</strong>&gt;</var></li>
          <li><code><b>--patch-module</b> <var>module_1</var>=<var>${buildDir}</var>/classes/java/test/<var>module_1</var></code>
              (repeat for each module)</li>
          <li><code><b>--add-modules</b></code> <var>&lt;same as for compilation of main code&gt;</var></li>
          <li><code><b>--add-reads</b></code> (as needed for test-only dependencies)</li>
          <li><code><b>--add-opens</b></code> (as needed for Jakarta or other libraries based on reflection)</li>
          <li><code><b>--add-exports</b></code> (as needed for allowing JUnit to test private package)</li>
        </ul>
      </li>
    </ul>
    <p>
      A lot of configuration can be done automatically with loops.
      The example below shows a small fragment of what a <code>build.gradle.kts</code> file
      may look like when there is no plugin for making the task easier.
      This example uses hard-coded Apache <abbr title="Spatial Information System">SIS</abbr> module names,
      but the principle is generalizable to other projects.
    </p>
    <pre class="snippet">plugins {
    `java-library`
}

var srcDir = file("<span class="use">src</span>")     // Root directory of all modules.
sourceSets {
    main {
        java {
            setSrcDirs(listOf(file(<span class="string">"<span class="use">src</span>/<span class="new">org.apache.sis.util</span>/<span class="use">main</span>/<span class="del">java</span></span>),
                              file(<span class="string">"<span class="use">src</span>/<span class="new">org.apache.sis.metadata</span>/<span class="use">main</span>/<span class="del">java</span></span>),
                              file(<span class="string">"<span class="use">src</span>/<span class="new">org.apache.sis.referencing</span>/<span class="use">main</span>/<span class="del">java</span></span>),
                              <span class="note">/* etc. We will use a plugin in Java for automation. /*</span> )
        }
    }
    test {
        java {
            setSrcDirs(listOf(file(<span class="string">"<span class="use">src</span>/<span class="new">org.apache.sis.util</span>/<span class="use">test</span>/<span class="del">java</span></span>),
                              file(<span class="string">"<span class="use">src</span>/<span class="new">org.apache.sis.metadata</span>/<span class="use">test</span>/<span class="del">java</span></span>),
                              file(<span class="string">"<span class="use">src</span>/<span class="new">org.apache.sis.referencing</span>/<span class="use">test</span>/<span class="del">java</span></span>),
                              <span class="note">/* etc. We will use a plugin in Java for automation. /*</span> )
        }
    }
}

fun addAllModules(args : List&lt;String&gt;) {
    args.add(<span class="string">"--add-modules"</span>)
    args.add(srcDir.list().joinToString(separator=","))
}

tasks.compileJava {
    options.compilerArgs.add(<span class="string">"--module-source-path=<span class="use">src</span>/<span class="new">*</span>/<span class="use">main</span>/<span class="del">java</span>"</span>)
    options.compilerArgs.add(<span class="string">"--module-path=${classpath.asPath}"</span>)
    setClasspath(files())   <span class="note">// For avoiding duplication with the <code>--module-path</code> option.</span>
    addAllModules(options.compilerArgs)
}

tasks.compileTestJava {
    options.compilerArgs.add(<span class="string">"--module-source-path=<span class="use">src</span>/<span class="new">*</span>/<span class="use">test</span>/<span class="del">java</span>"</span>)
    options.compilerArgs.add(<span class="string">"--module-path=${classpath.asPath}"</span>)
    setClasspath(files())
    srcDir.list().forEach {
        options.compilerArgs.add(<span class="string">"--patch-module"</span>)
        options.compilerArgs.add(<span class="string">"${it}=<span class="use">src</span>/${it}/<span class="use">test</span>/<span class="del">java</span>"</span>)
        options.compilerArgs.add(<span class="string">"--add-reads"</span>)
        options.compilerArgs.add(<span class="string">"${it}=org.apache.sis.test,junit"</span>)
    }
    addAllModules(options.compilerArgs)
    <span class="note">// Add more <code>--add-reads</code> and <code>--add-exports</code> project-specific options as needed.</span>
}

tasks.test {
    useJUnitPlatform()
    /*
     * Create a module path which excludes the compiled test classes, because those
     * classes will be specified using another JVM option (namely `--patch-module`).
     */
    val mainpath = classpath.filter {
        path : File ->
        !path.getName().equals(<span class="use">test</span>)
    }
    val args = mutableListOf(<span class="string">"--module-path"</span>, mainpath.asPath)
    srcDir.list().forEach {
        args.add(<span class="string">"--patch-module"</span>)
        args.add(<span class="string">"${it}=${buildDir}/classes/java/<span class="use">test</span>/${it}"</span>)
        args.add(<span class="string">"--add-reads"</span>)
        args.add(<span class="string">"${it}=junit,ALL-UNNAMED"</span>)
    }
    addAllModules(args)
    <span class="note">// Add more <code>--add-reads</code> and <code>--add-exports</code> project-specific options as needed.</span>
    setAllJvmArgs(args)
}</pre>

    <p>
      This complexity can be handled by a customized Gradle plugin in Java. Details about how to do so are given in the
      <a href="https://docs.gradle.org/current/userguide/implementing_gradle_plugins.html">Gradle documentation</a>
      and are not repeated here. Some parts that can be moved from <code>build.gradle.kts</code> script to Java code
      are the full <code>sourceSets</code> configuration, together with the class-path and module-path settings,
      and the <code>--source-module-path</code>, <code>--add-modules</code> and <code>--patch-modules</code> options.
      Some (but not all) <code>--add-exports</code> options can also be managed by the plugin.
      Source code of a plugin developed specifically for Apache SIS can be seen below.
      It could be generalized to arbitrary projects if there is an interest.
    </p>
    <ul>
      <li><a href="https://github.com/Geomatys/sis/blob/Jigsaw/buildSrc/src/org.apache.sis.buildtools/main/org/apache/sis/buildtools/gradle/CompileExtension.java">CompileExtension.java</a></li>
      <li><a href="https://github.com/Geomatys/sis/blob/Jigsaw/buildSrc/src/org.apache.sis.buildtools/main/org/apache/sis/buildtools/gradle/TestExtension.java">TestExtension.java</a></li>
    </ul>

    <h3>3.1) Gradle issues and workarounds</h3>
    <p>
      Above configuration works but has the following problems with Gradle 8.2.
      Workarounds for current Gradle version are presented in this section.
      Proposed Gradle evolutions are proposed in a <a href="#gradle-proposals">later section</a>.
      The issue that caused the greatest difficulties for us is the Gradle automatic dispatching
      of dependencies between the <code>--class-path</code> and <code>--module-path</code> options.
      The other issues could be summarized as "Insufficient control on the options passed to the command".
    </p>
    <h4>3.1.1) Automatic dispatching between class-path and module-path does not work</h4>
    <p>
      Gradle uses a set of heuristic rules for deciding if a dependency should be declared on the class-path or on the module-path.
      But heuristic rules tend to work well only in some specific contexts, which is currently restricted to package hierarchy.
      As of Gradle 8.2.1, those heuristic rules do not recognize any module in our Source Module Hierarchy.
      In particular, the automatic dispatching of dependencies is enabled only if Gradle believes that the
      sub-project being compiled is itself a <abbr title="Java Platform Module System">JPMS</abbr> module,
      and Gradle does not recognize above configuration as such.
      The Gradle's
      <a href="https://docs.gradle.org/8.2/javadoc/org/gradle/api/jvm/ModularitySpec.html"><code>ModularitySpec</code></a>
      class does not provide an option for forcing the activation of automatic dispatching.
      The current workaround is to make explicit calls to methods of Gradle API such as
      <code>setClasspath(…)</code> for overwriting the class-path and module-path defined by Gradle.
    </p>
    <h4>3.1.2) Automatic dispatching between class-path and module-path is not always desirable</h4>
    <p>
      The Gradle <code>ModularitySpec</code> implementation could be improved for recognizing a larger set of hierarchies,
      but even better automatic detection will not always work.
      Sometime we want to force a dependency to be on the module-path no matter what Gradle thinks.
      It happens for example when a dependency has no <code>module-info.class</code> file
      and no <code>Automatic-Module-Name</code> entry in the <code>MANIFEST.MF</code> file,
      but we still want to handle it as an automatic module.
      Some may argue that this is bad practice, but this is sometime necessary for getting tools to work.
      In Apache <abbr>SIS</abbr> case, all those automatic modules are optional dependencies.
      We need a way to control whether a dependency should be considered as a module or not on a case-by-case basis.
    </p>
    <h4>3.1.3) Unexpected class-path changes after configuration</h4>
    <p>
      In the Javadoc task, it is difficult to modify the class-path and module-path options
      because the class-path is modified again by Gradle after our configuration.
      So the class-path was incomplete at the time we copied its entries to the module-path,
      and the class-path receives undesired new entries after we cleared it.
      This behavior causes Javadoc generation to fail, with no workaround we could find so far.
      However a manual workaround exists by opening the <code>build/tmp/javadoc/javadoc.options</code>
      file in an editor, move the <code>-classpath</code> content to <code>--module-path</code>,
      then run <code>javadoc @build/tmp/javadoc/javadoc.options</code> on the command line.
      Because Javadoc are generated less often than compilation,
      we think that this workaround is acceptable until a better solution become available.
    </p>
    <h4>3.1.4) Repeated module path</h4>
    <p>
      Adding the <code>--module-path</code> in the compiler options cause the option to appear twice
      in the debug output of Gradle 8.2. The two occurrences have the exact same path, which may be large.
      We found no way to prevent that duplication, as it does not appear in the list returned by
      <a href="https://docs.gradle.org/8.2/javadoc/org/gradle/api/tasks/compile/CompileOptions.html#getCompilerArgs--"><code>CompilerOptions.getCompilerArgs()</code></a>.
      Our current workaround is to do nothing,
      as <code>javac</code> seems to work anyway with duplicated elements on the module path.
    </p>
    <h4>3.1.5) Source path incompatibility</h4>
    <p>
      In the same way that <code>--class-path</code> and <code>--module-path</code> should specify mutually exclusive sets,
      <code>--source-path</code> and <code>--module-source-path</code> should also be mutually exclusive options.
      The <code>--source-path</code> option is considered rarely needed in modern builds and can be omitted.
      But the Gradle's debug output seems to unconditionally provide the latter option at least with an empty string,
      because the empty string has a different meaning than the default <code>javac</code> value.
      Using the Gradle <abbr>API</abbr> for setting the source path to <code>null</code> does not help since Gradle
      <a href="https://docs.gradle.org/8.2/javadoc/org/gradle/api/tasks/compile/CompileOptions.html#getSourcepath--">interprets that as an empty path</a>.
      We saw no <abbr>API</abbr> for telling Gradle to omit completely that option.
      This is a problem since the <code>--module-source-path</code> option is necessary for specifying the
      <code><span class="use">src</span>/<span class="new">*</span>/<span class="use">main</span>/<span class="del">java</span></code> pattern.
      Consequently when launching <code>javac</code> on the command-line with the options shown by Gradle's debug output,
      we get the following error:
    </p>
    <blockquote><code>error: cannot specify both --source-path and --module-source-path</code></blockquote>
    <p>
      Our current workaround is to do nothing.
      The Java compiler seems to work inside Gradle, even if it doesn't work on the command-line with Gradle's debug output.
    </p>




    <h2>4) Advantages of Source Module Hierarchy</h2>
    <p>
      The use of <i>Module Source Hierarchy</i> instead of <i>Package Hierarchy</i> has advantages and inconvenient.
      Advantages for the Apache <abbr title="Spatial Information System">SIS</abbr> project are described below.
      The main inconvenient is the poor support in current build tools and
      <abbr title="Integrated Development Environment">IDE</abbr>.
      However the latter is not a blocker, and we can try to contribute in improving the situation with proposals
      such as the "<a href="#gradle-proposals">Ideas for Gradle evolution</a>" section at the bottom of this page.
    </p>
    <h3>4.1) Aggregated output generation without resorting to hacks</h3>
    <p>
      Most JDK tools are <abbr title="Java Platform Module System">JPMS</abbr> aware
      and can process many modules in one invocation of each command-line tool.
      In some cases, the same result can be obtained by invoking the same tool repetitively for each module, but not always.
      The most obvious example where the result differs is <code>javadoc</code>.
      When executed for a group of modules instead of invoked repetitively for each module,
      <code>javadoc</code> can generate an aggregated <abbr title="Application Programming Interface">API</abbr> documentation
      with a home page listing all modules, an index with entries from all modules,
      hyper-links to modules beyond the boundary of what is declared in <code>module-info</code>
      (for example lists of all implementations of each interface), <i>etc.</i>
      Such aggregation does not fit naturally in the Maven directory layout.
      Maven does support aggregated Javadoc, but this support requires hacks and may not be easily applicable to other tools.
      An example of another tool for which aggregated execution is sometime useful is annotation processor.
      More use cases may appear in future Java versions (e.g. multi-modules archive files?).
      A native support of Module Source Hierarchy in Gradle would make easier to leverage those features
      with less needs to resort to hacks.
    </p>
    <h3>4.2) Compile-time verification of Javadoc links</h3>
    <p>
      Suppose that module <var>B</var> depends on module <var>A</var>.
      Module <var>B</var> can have compile-time dependencies toward <var>A</var> (backward references),
      but the converse (a forward reference from <var>A</var> to <var>B</var>) is illegal for the compiler.
      However such forward references are perfectly legal in <em>documentation</em>,
      and indeed the <code>javadoc</code> tool handles them well.
      It is possible to write Javadoc <code>{@link}</code> and <code>{@see}</code> tags in module <var>A</var> with
      forward references to some <abbr title="Application Programming Interface">API</abbr> in module <var>B</var>.
      However doing so with Maven directory layout requires that we sacrifice a safety.
      The <code>javac</code> tool offers the possibility to verify Javadoc <code>{@link}</code> and <code>{@see}</code>
      tags at compile-time. This feature offers much faster error detections than waiting for Javadoc generation,
      because the latter is done less frequently than compilation.
      This verification can be enabled by passing the <code>-Xdoclint:all</code> option to <code>javac</code>,
      in which case any invalid <code>{@link}</code> or <code>{@see}</code> tag causes a compilation error.
      It works well with references to <abbr title="Application Programming Interface">API</abbr> in the same module
      or in dependencies, but cannot work with forward references unless <code>javac</code> knows that those modules
      exist and what they contain.
      This is possible with Module Source Hierarchy, but not with Maven directory layout.
      With the latter, all forward references are flagged as errors.
      With the former, compile-time verification of <code>{@link}</code> or <code>{@see}</code> tags,
      including forward references, works like a charm.
    </p>
    <h3>4.3) Easier reuse of test fixtures</h3>
    <p>
      The test code for a module may create test fixtures, mocks or assertion methods
      that we want to reuse in the test code of dependent modules.
      With Maven, we have to package the test classes in an artifact of type <code>test-jar</code>.
      With the module source hierarchy, this is no longer necessary if the test fixtures are reused
      only inside the same sub-project. For example if test fixtures are provided in the
      <code>org.apache.sis.test</code> package under the
      <code><span class="use">test</span>/<span class="del">java</span></code>
      sub-directory of the <code>org.apache.sis.util</code> module,
      then all other modules in the same sub-project can access those text fixture by adding
      the following script in the <code>build.gradle.kts</code> file,
      with nothing to package or deploy:
    </p>
    <pre class="snippet">tasks.compileTestJava {
    <span class="note">(…snip…)</span>

    var <var>allModules</var> = file("<span class="use">src</span>").list().joinToString(separator=<span class="string">","</span>)
    args.add(<span class="string">"--add-exports"</span>)
    args.add(<span class="string">"org.apache.sis.util/org.apache.sis.test=${<var>allModules</var>}"</span>)
}</pre>

    <h3>4.4) Control on test environment</h3>
    <p>
      A side-effect of the proposal described in this page is that the tests of all modules in a Gradle sub-project
      are executed together in the same <abbr title="Java Virtual Machine">JVM</abbr>.
      It may be considered against unit test principles, but actually this is controllable.
      First we note that having all modules in the <abbr title="Java Virtual Machine">JVM</abbr>
      during test execution is not necessarily a bad thing.
      It sometime happens that a test behaves differently when the module is alone in the <abbr>JVM</abbr>
      compared to when all modules are present.
      Because the latter scenario is more representative of production environment than the former,
      some bugs were unnoticed because of that.
      Some peoples will argue that integration tests should have discovered the issue,
      but it is hard to have an extensive coverage for all kinds of tests.
      With the Module Source Hierarchy, the easiest configuration it to let all tests
      be executed in the same <abbr title="Java Virtual Machine">JVM</abbr>.
      However we think that it should be possible to filter which modules to load in the <abbr>JVM</abbr>.
      It could be a configuration option in Gradle for running the same tests with different sets of modules.
    </p>
    <h3>4.5) Speed</h3>
    <p>
      We have not done yet serious benchmarks, but compiling all modules from scratch seems a little bit faster when
      <code>javac</code> is invoked once for all modules compared to invoking <code>javac</code> for each module.
      Likewise, tests are also faster presumably because common dependencies are loaded only once and the caching
      mechanisms of the tested application takes effect
      (see the previous section for a discussion about running the tests of all modules together).
      However, speed is not the main criterion regarding the use (or not) of Module Source Hierarchy.
    </p>




    <h2>5) Limitations</h2>
    <p>
      The Module Source Hierarchy is not best suited to every situations.
      This section describes some cases where the Maven hierarchy currently supported by Gradle may be better suited.
    </p>
    <h3>5.1) No support from main build tools</h3>
    <p>
      As of July 2023, neither Maven or Gradle provides out-of-the-box support for Module Source Hierarchy.
      A very good out-of-the-box support (actually the major source of inspiration for the proposal in this page)
      is provided by the NetBeans <abbr>IDE</abbr> when using the NetBeans Ant build system,
      but the NetBeans community itself encourages the use of Maven or Gradle instead of Ant.
      Nevertheless, the flexibility of Gradle compared to Maven makes possible to use Module Source Hierarchy
      with some efforts, but the task could be made much easier with a little bit of Gradle improvements
      such as the ones proposed <a href="#gradle-proposals">at the end of this page</a>.
    </p>
    <h3>5.2) Generated code seems difficult to add</h3>
    <p>
      As of Gradle 8.2, the ANTLR task
      <a href="https://discuss.gradle.org/t/antlr-plugin-directory-issues-gradle-2-7/17889">does not work well
      with arbitrary source directories</a>. We have to keep the default conventions of the ANTLR plugin even
      if those conventions do not fit well in Module Source Hierarchy.
      Another problem is that we didn't found the right compiler options for combining a directory
      of generated sources with the main sources in a Module Source Hierarchy, so we have to write
      the output directly in main source directory. In Apache <abbr>SIS</abbr> case this problem
      is hopefully temporary, because we plan to replace ANTLR generated code by hand-written code.
    </p>




    <h2>6) Conclusion</h2>
    <p>
      Maven and Gradle uses "convention-over-configuration" approach to build <abbr>JVM</abbr>-based project.
      A problem with that approach is that it works well for a few years,
      but when the convention become no longer suited to the language evolution,
      it is very difficult to changes the habits.
      I suspect that Maven conventions are a reason for the slow <abbr title="Java Platform Module System">JPMS</abbr> adoption.
    </p>
    <h3 id="gradle-proposals">6.1) Ideas for Gradle evolution</h3>
    <p>
      Full <abbr title="Java Platform Module System">JPMS</abbr> support,
      i.e. having the possibility to use the <code>javac</code> <i>Module Source Hierarchy</i> when desired
      instead of being restricted to the <i>Package Hierarchy</i>, has some advantages described in this page.
      There is also inconvenient, but the intend is not to force developers to use Source Module Hierarchy.
      The intend is to make easy to use either the package or source module hierarchy when desired.
      Gradle could help in different ways, described below.
      The most critical issue, almost a blocker, is the first one.
    </p>
    <h4>6.1.1) Explicit control over "class-path versus module-path" detection</h4>
    <p>
      The current automatic dispatching of dependencies on class-path <i>versus</i> module-path does not work with Module Source Hierarchy.
      Even if it was fixed, it would break again if a new hierarchy was introduced in the future.
      Even if an automagic algorithm was able to work for every hierarchies, automatic dispatching is not always desirable.
      Sometime the developer really wants a dependency to be declared on <code>--module-path</code> even if it is not modularized,
      because the consequences on the modules that use this dependency are not the same.
    </p><p>
      We could complete or replace the <code>inferModulePath</code> property in
      <a href="https://docs.gradle.org/8.2/javadoc/org/gradle/api/jvm/ModularitySpec.html"><code>ModularitySpec</code></a>
      for making possible to force the automatic dispatching of dependencies between class-path and module-path
      without relying on the conditions documented in the <code>getInferModulePath()</code> method.
      Alternatively Gradle could be enhanced for recognizing the Source Module Hierarchy itself.
      But in any cases, we would still need a way to <em>force</em> a dependency to be on the module-path no matter what Gradle thinks.
      One possibility may be to expand the syntax of <code>dependencyResolutionManagement</code>.
      For example (<span class="use">green elements</span> are what currently exist,
      <span class="new">blue element</span> is tne proposal with exact syntax to be discussed):
    </p>
    <pre class="snippet"><span class="use">dependencyResolutionManagement</span> {
    <span class="use">versionCatalogs</span> {
        <span class="use">create</span>(<span class="string">"libs"</span>) {
            <span class="use">library</span>(<span class="string">"jts.core"</span>, <span class="string">"org.locationtech.jts"</span>, <span class="string">"jts-core"</span>) {
                <span class="use">version</span> {
                    <span class="use">strictly</span>(<span class="string">"[1.15, 2.0["</span>)
                    <span class="use">prefer</span>(<span class="string">"1.19.0"</span>)
                }
                <span class="new">JPMS</span> {
                  <span class="new">type</span>(<span class="string">"module"</span>)   <span class="note">// Other allowed values: "unnamed" or "auto" (the default)</span>
                }
            }
        }
    }
}</pre>
    <p>
      The <code><span class="new">type</span>(<span class="string">"module"</span>)</code> element would mean
      "always put this dependency on the <code>--module-path</code> option".
      Conversely <code><span class="new">type</span>(<span class="string">"unnamed"</span>)</code>
      would mean to always put on the <code>--class-path</code> option,
      and <code><span class="new">type</span>(<span class="string">"auto"</span>)</code>
      would be the current behavior.
      The rational for putting this information in <code>dependencyResolutionManagement</code> is that,
      like version numbers, the dependency type (module <i>versus</i> unnamed) should be consistent in all sub-projects.
      This is because a larger project combining many sub-projects will be able to make only one "class-path versus module-path"
      choice per dependency.
    </p><p>
      This <code><span class="new">type</span>(<span class="string">"module"</span>)</code> proposal is the only thing
      that we need for resolving the biggest difficulty encountered so far in using Gradle with Module Source Hierarchy.
      However this new <code><span class="new">JPMS</span></code> block could be extended in the future with more features.
      For example we could define an
      <code><span class="new">importAllPackages</span>(<span class="string">"org.apache.sis.*"</span>)</code> method
      meaning that when this dependency is used, then an <code>--add-exports</code> compiler option should be automatically added
      for exporting to that dependency all non-exported packages of each module whose name starts with <code>"org.apache.sis."</code>.
      It would be useful for testing with JUnit.
      Similar methods could be added for <code>--add-opens</code>, <code>--patch-module</code>, <i>etc.</i>
    </p>
    <h4 id="javac-options">6.1.2) Full control over all Java compiler options</h4>
    <p>
      Provide a way to set the all compiler options, including the ones managed by Gradle itself.
      Currently the <a href="https://docs.gradle.org/8.2/javadoc/org/gradle/api/tasks/compile/CompileOptions.html"><code>CompilerOptions</code></a>
      class has a <code>getCompilerArgs()</code> method providing a mutable list,
      but that list is only for <em>additional</em> options appended after the options managed by Gradle.
      There is also a <code>get<u>All</u>CompilerArgs()</code> method, but that list is immutable.
      The reason why full control on all compiler options is sometime desired
      is because latest Java releases may have new features that are incompatible with the options managed by Gradle.
      Example of incompatible new Java compiler options are <code>-release</code> and <code>--module-source-path</code>.
      The former is supported by Gradle 8.2, but not the latter. Even if Gradle resolves this incompatibility,
      we cannot know in advance what would be the next incompatible options in future Java releases.
      We may also want to do cleanups such as removing the <code>--module-path</code> duplication.
    </p>
    <p>
      The same argument applies to other tools as well.
      Currently the lack of full control on <code>javadoc</code> options is a blocker issue for generating the Javadoc,
      forcing us to launch <code>javadoc</code> directly on the command-line instead.
      We accept this problem as a hopefully temporary inconvenience since Javadoc is not generated
      as often as the <abbr>JAR</abbr> files.
    </p>
    <h4>6.1.3) Allow to specify the test classes as a list of <code>java.lang.Class</code> objects</h4>
    <p>
      The test classes are currently specified as a list of files.
      Gradle infers the class name from the file name, then invoke <code>Class.forName(String, ClassLoader)</code>.
      But the class name inferred by Gradle is wrong when the project layout is not as expected by Gradle.
      Other reasons why developers way want to instantiate the <code>Class</code> themselves may be if they need
      some control on the <code>ClassLoader</code> or <code>ModuleLayer</code> to use for loading the classes.
    </p>
  </body>
</html>
